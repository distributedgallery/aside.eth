// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

import {ERC721, ERC721URIStorage} from "openzeppelin-contracts/contracts/token/ERC721/extensions/ERC721URIStorage.sol";
import {IERC721} from "openzeppelin-contracts/contracts/token/ERC721/IERC721.sol";

error UnknownProposal(uint256 proposalId);
error DoubleVote(uint256 proposalId, address voter);
error InvalidNFT();
error InvalidOwnership();

contract AsideV1 is ERC721URIStorage {
    enum State {
        Null,
        Locked,
        Unlocked
    }

    struct Lock {
        State state;
        IERC721 collection;
        uint256 tokenId;
        uint256 unlockDate;
    }

    mapping(uint256 => Lock) private _locks; // spectre => NFT
    mapping(address => mapping(uint256 => uint256)) _spectres; // ERC721 => spectre [re-initialized when unlocked];

    mapping(address => bool) _isApprovedCollection;

    constructor() ERC721("Aside", "ASD") {}

    /// @notice Retrieves the stream's start time, which is a Unix timestamp.
    /// @dev The NFT to be locked can be :
    ///      1. Owned by this contract, either :
    ///         1.1 Registered through a lock, or
    ///         1.2 Unregistered through a lock [e.g. because it has been sent with no Receiver check].
    ///      2. Owned by someone else.
    ///
    ///      1. Already locked.
    ///      2. Not locked yet.
    ///      - We do not check that `collection` actually is an ERC721 [or pretend to] as collections are whitelisted.
    ///      - We do not check that `collection`#`Ã¬d` is not owned by this contract has we already check for actually is an ERC721 [or pretend to] as collections are whitelisted.
    /// @param collection The address of the ERC721 contract whose NFT is to be locked.

    // if the NFT is owned by this contract and not represented by a spectre / shadow token because it has been sent with no Receiver check
    // then if someone
    function lock(IERC721 collection, uint256 tokenId, uint256 duration) external {
        if (collection.ownerOf(tokenId) != msg.sender) revert InvalidOwnership();
        if (_arkhes[collection][tokenId].isLocked) revert InvalidOwnership();
        if (!_isWhitelisted[collection]) revert InvalidCollection();

        Lock storage lock = _locks[collection][tokenId];

        collection.transferFrom(tokenId, address(this));
        lock.state = State.Locked;
        lock.collection = collection;
        lock.tokenId = tokenId;
        lock.unlockDate = block.timestamp + duration;

        // // in case the NFT accidentally ended up owned by this contract while un-fractionalized
        // require(
        //     owner != address(this),
        //     "Vault: NFT is already owned by this vault"
        // );
    }

    // if (spectre.state == Spectres.State.Locked) {
    //             try IERC721Metadata(address(spectre.collection)).tokenURI(spectre.tokenId) returns (string memory uri_) {
    //                 return uri_;
    //             } catch {
    //                 return _unavailableURI;
    //             }
    //         }

    //         if (spectre.state == Spectres.State.Unlocked) return _unlockedURI;

    // function _mint(address to, uint256 tokenId) internal {
    //     function _setTokenURI(uint256 tokenId, string memory _tokenURI)
    // }

    //     uint256 public nbOfProposals;
    //     mapping(uint256 => Proposal) public proposals;

    //     function propose(string calldata _description) external {
    //         Proposal storage proposal = proposals[nbOfProposals];

    //         proposal.exists = true;
    //         proposal.author = msg.sender;
    //         proposal.description = _description;
    //         nbOfProposals++;
    //     }

    //     function vote(uint256 _proposalId, bool _yeah) external {
    //         Proposal storage proposal = proposals[_proposalId];

    //         if (!proposal.exists) revert UnknownProposal(_proposalId);
    //         if (proposal.hasVoted[msg.sender])
    //             revert DoubleVote(_proposalId, msg.sender);

    //         proposal.hasVoted[msg.sender] = true;

    //         if (_yeah) proposal.yeahs++;
    //         else proposal.neahs++;
    //     }

    //     function hasVoted(
    //         uint256 _proposalId,
    //         address _who
    //     ) public view returns (bool) {
    //         return proposals[_proposalId].hasVoted[_who];
    //     }

    //     function getProposal(
    //         uint256 _proposalId
    //     )
    //         public
    //         view
    //         returns (
    //             bool exists,
    //             address author,
    //             string memory description,
    //             uint256 yeahs,
    //             uint256 neahs
    //         )
    //     {
    //         Proposal storage proposal = proposals[_proposalId];

    //         exists = proposal.exists;
    //         author = proposal.author;
    //         description = proposal.description;
    //         yeahs = proposal.yeahs;
    //         neahs = proposal.neahs;
    //     }
}
